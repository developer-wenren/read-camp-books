# 第六期 《Effective Java中文版（第3版）》
> 阅读计划：每天 5 条，总共18天。读六天，复习一天，截止 20190823。

## 第1条 用静态工厂方法代替构造器

- 有什么好处？

- 如何做到？

### 五大使用静态工厂方法的优势

1. 允许提供更有意义的名称，更利于理解和使用，而不是固定的构造器名称。
2. 可以避免重复创建对象，节省内存，对预先创建的对象进行缓存，反复使用。
3. 可以指定类的任意子类对象，利用多态，更加灵活
4. 允许在内部实现中包含的类不存在，如 服务提供者接口（SPI），JDBC
5. 允许根据不同参数构造不同的对象，多个构造器方法容易调用错。



### 常见的静态工厂方法惯用名称

- from： 类型转换方法，它只有单个参数，返回该类型的一个相对应的实例

	```java
	Date d = Date.from(instant);
	```

- of：聚合方法，带有多个参数，返回该类型的一个实例，把它们合并起来

	```java
	Set<Rank> faceCards = EnumSet.of(JACK , QUEEN, KING);
	```

- valueOf： from 和 of 更烦琐的一种替代方法

	```java
	Biginteger a = Biginteger.valueOf(Integer.MAX_VALUE);
	```

- instance 或者 get Instance一－返回的实例是通过方法的（如有）参数来 描述

	的，但是不能说与参数具有同样的值

	```java
	StackWalker luke = StackWalker .getinstance(options);
	```

- create 或者 newInstance一一像 instance 或者 getInstance 一样，但 create 或者 newInstance 能够确保每次调用都返回一个新的实例

	```java
	Object newArray = Array.newinstance(classObject, arraylen)
	```

- getType：像 get Instance 一 样，但是在工厂方法处于不同的类中的时候使 用 。 Type 表示工厂方法所返回的对象类型

	```java
	FileStore fs = Files.getFileStore(path);
	```

- newType：像 newInstance 一样，但是在工厂方法处于不同的类中的时候使用,Type 表示工厂方法所返回的对象类型

	```java
	BufferedReader br＝ Files.newBufferedReader(path);
	```

- type：getType 和 newType 的简版

	```java
	List<Complaint> litany ＝Collections.list(legacylitany);
	```

### 小结

构建实例时，优先考虑静态工厂，而不是第一反应定义构造器方法；多考虑静态工厂，多考虑静态工厂，考虑静态工厂。

## 第2条. 遇到多个构造器参数时要考虑使用构建器

- 为什么要这样做？
- 怎么做？

### 建造者模式 Builder Pattern

面对构建一个对象需要大量必备参数和可选参数时，使用构造器方式构建往往混乱难以维护，并且容易出错；利用建造者模式 Builder Pattern，使用 构建器对象 `builder` 来构建对象所需要的参数，必填参数作为构造器参数，可选参数采用赋值方法，结合流式 API 方式通过 `build` 方法构建完整对象.

![](http://ww2.sinaimg.cn/large/006tNc79ly1g5p6do7nljj30me0stmyv.jpg)

### 小结

当类的构造器或者静态工厂中具有多个参数，设计这种类时，优先考虑 Builder 模式，尤其是大多数参数可选或者类型相同的情况下，这样可读性好，有便于维护。

初次之外还可以利用 Lombok 框架的 @Builder 注解，自动生成  Builder 模式的固定代码。

## 第3条 用私有构造器或者枚举类型强化 Singleton 属性

怎么用到枚举类型？

对单例的要求哪有？

作为一个单例，全局唯一，只能有一个实例，并且反序列后仍是同个实例，这一点必须实现 `Serializable` 接口和 `readResolve()` 方法解决。

### 单元素枚举实现单例

单例对象要求防止被重复实例化，以及反序列和序列化后都是同一个实例，优先采用单元素枚举类型的实现方式。

![](http://ww1.sinaimg.cn/large/006tNc79ly1g5p6gjmznoj311s0i2mym.jpg)


### 小结

枚举类型单例也有局限，当单例需要扩展于一个父类时，不能基于 Enum 扩展。

如果需要一个没有父类的单例对象，可以考虑使用枚举方式定义。



## 第4条 通过私有构造器强化不可实例化的能力

- 通用的解决方式是什么样的？
- 针对哪些类

为这个类定义一个私有构造器，它就不能被实例化，并且提供调用的异常提示。

缺陷在于该类就无法被继承使用，因为所有构造器都必须调用父类构造器。

### 小结

通常只提供静态方法和静态字段的类，需要对构造器私有化处理。


## 第5 条 优先考虑依赖注人来引用资源

- 什么场景下使用依赖注入？
- 依赖注入有什么副作用吗？

### 依赖注入 DI

当构建一个实例时，所需的资源通过构造器方式或者特定的赋值方法传入，而不是用静态工具类和单例类使用底层资源。

### 小结

依赖注入虽然灵活，易于测试，但是当依赖过多和关系复杂时就难以维护。



## 第6条 避免创建不必要的对象

> 哪些场景下可以重用对象?

重用对象可以提供性能。

对于不可变的对象来说，一直是可以被重用的。

对于已知不会被修改的可变对象，也可以重用。

> 如何重用对象？

- 自动装箱会创建多余对象，应该优先使用基本类型。

- 针对重量级对象，合理利用对象池，比如数据库连接池，线程池。

- 使用正则表达式，单独声明 Pattern 实例再使用

## 第7条 消除过期的对象引用

> 怎么算过期的引用

过期引用 （ obsolete reference ）: 永远也不会再被解除的引用，但不会被访问到。

过期引用会导致出现内存泄漏，需要及时地清空引用。

当类自己管理内存时，就应该警惕内存泄漏问题，及时清空不被使用的引用。

常见的过期引用场景：

- 自动管理内存

- 缓存
- 监听器和回调，用弱引用处理



如何发现内存泄漏

1. 仔细检查代码
2. 借助 Heap 剖析工具，如 MAT。



## 第8条 避免使用finalize方法和cleaner方法

> 为什么不要使用这些方法？

这些方法执行跟 JVM 相关;

严重拖慢性能;

存在安全问题，执行恶意的 finalize 方法，形成攻击。



## 第9条 try-with-resources 优先于 try-finally

Java 7 引入 try-with-resource 语句，资源类实现 `AutoCloseable` 接口

 try-with-resource 支持 

```java
static String firstLineOfFile(String path) throws IOException {
  try (BufferedReader br = new BufferedReader(new FileReader(path))) {
    return br.readLine();
  }
}

static void copy(String src, String dest) throws IOException {
  try (InputStream in = new FileInputStream(src); OutputStream out = new FileOutputStream(dest)) {
    byte[] buffer = new byte[1024];
    int n;
    while ((n = in.read(buffer)) >= 0) {
      out.write(buffer, 0, n);
    }
  }
}
```

### 小结

在处理必须关闭的资源时，始终要优先考虑用 try-with-resources ，而不是 用 try-finally 。 这样得到的代码将更加简洁、清晰，产生的异常也更有价值。



## 第10条 覆盖 equals 时请遵守通用约定

不要随意覆盖 equals 方法：

- 类的每个实例本质上都是唯一的
- 类没有必要提供“逻辑相等”（ logical equality ）的测试功能
- 超类已经覆盖了 equals ，超类的行为对于这个 类 也是合适的
- 类是私有的 ， 或者是包级私有的 ， 可以确定它的 equals 方法永远不会 被调用 。



如何实现 equals 方法：

1. 使用＝＝操作符检查“参数是否为这个对象的引用”。
2. 使用 instanceof 操作符检查“参数是否为正确的类型”。
3. 把参数转换成正确的类型。
4. 对于该类中的每个“关键”（ significant ）字段，检查参数中的字段是否与该对象中对应的字段相匹配。
5. 覆盖 equals 时总要覆盖 hashCode。

##  第11条 覆写 equals 方法总要覆盖 hashCode 方法

> 为什么需要这样做？

在一些基于`Hash` 的集合里就无法正常的工作，如 `HashMap`，`HashSet`。

两个对象 `equals` 方法不相等，`hashCode` 方法不一定也相等，但尽量保证两个方法的一致

> 如何正确地覆写 `hashCode` 方法

结合对象的关键字段进行组合 `hash` 作为对象的 `hashCode` 。

```java
@Override public int hashCode() {
	return Objects.hash(linenum, prefix, areacode)
}
```

注意：如果计算对象的哈希码开销较大时，可以考虑缓存方式，延迟加载初始化 `hashCode`。

## 第12条 始终覆盖 toString 方法

提供自定义的 `toString` 实现，在日志打印时让对象更加容易查看，便于调试，将方法里返回对象包含的所有需要关注的值。

## 第13条 不要轻易覆盖 clone 方法

`clone` 方法的作用就是可以无须调用构造器就可以创建对象。

`clone` 方法与可变对象的 final 字段不兼容。

如何克隆复杂对象是，先调用 `super . clone` 方法，然后把结果对象中的 所有域都设置成它们 的初始状态（ initial state ），然后调用高层（ higher-level ）的方法来重 新产生对象的状态 。

对象拷贝的更好的办法是提供一个拷贝构造器（ copy constructor）或拷贝工厂（ copy factory ）



## 第14条 考虑实现 Comparable 接口

如果实现了 `Comparable` 接口，那么在通常情况下应该返回与 `equals` 方法同样的结果。

如果第一个值小于第二个值，则为负；如果两个值相等 ，则为零 ；如果第一个值大于第二个值，则为正 。

需要比较时，可以使用 Comparator 接口中比较器构造方法。



## 第15条 使类和成员的可访问性最小化

也叫做封装，尽可能地使每个类或者成员不被外界访问 。

可访问性关键字从低到高：

- private
- package-private 默认
- protected
- public

公共类都不应该包含 `public` 字段，并且 要确保公有静态 `final` 域所引用的对象都是不可变的 。



## 第 16 条：要在公共类使用方法访问字段，而不是将其公开

如果类可以在它所在的包之外进行访问，就应该提供访问方法。

## 第 17 条：使可变性最小化

> 什么是不可变类

实例不能被修改的类，如 String，基本类型包装类。

> 如何变成不可变类

- 不提供任何赋值方法
- final 修饰，保证类不会被扩展
- 声明所有的字段都是 final 修饰
- 所有方法都是私有的
- 不允许外部获取实例内引用指向可变对象的字段

> 不可变对象的优势在哪

不可变对象是线程安全的，可以共享它们的内部信息，状态始终保持一致性。

构造器应该创建完全初始化的对象 ，并建立起所有的约束关系。

## 第 18 条：复合优先于继承

> 为什么不使用继承

继承打破了封装性，让子类依赖其父类的实现细节。

> 什么是复合

在新的类中增加一个私有字段，引用现有类的一个实例，新类中的每个实例方法都可以调用被包含的现有类实例中对应的方法，并返回它的结果 。

## 第 19 条：如果使用继承要提供文档说明

父类必须有文档说明它可覆盖的方法的自用性。并且在发布类之前先编写子类对类进行测试。

父类的约束：构造器决不能调用可被覆盖的方法，避免子类覆写后行为异常。

## 第 20 条：接口优于抽象类

> 什么是 mixin 类型

类除了实现 它的“基本类型”之外，还可以实现特定接口提供了某些可供选择的行为，如 Comparable 接口。

接口通常是定义允许多个实现类型的最佳途径。

## 第 21 条 ： 为后代设计接口

Java 8 引入新特性：让接口可以用默认实现的方法。但是接口的现有实现就不会出现编译时没有报错或警告，运行时却失败的情况 ，仍要谨慎设计接口，为接口添加默认方法时候要全面测试。

## 第 22 条：接口只用于定义类型

不要用接口用来定义常量类，一旦这个接口被非`final`类实现了，所有子类 的命名空 间也会被接 口中的常量所“污染”。替代方案是使用枚举类型或者不可实例化的工具类。

## 第 23 条 ： 类层次优于标签类

> 什么是标签类

包含表示实例风格字段的类，充斥着样板代码，包括枚举声明、标签字段以及条件语句 。

标签类过于冗长、容易出错，并且效率低下，替代的方案为拆成类，进行层次维护，用来反映类型之间本质上的层次关系，有助于增 强灵活性，并有助于更好地进行编译时类型检查 。

## 第 24 条 ： 静态成员类优于非静态成员类

嵌套类有四种：静态成员类，非静态成员类，匿名类，局部类。

- 静态成员类用于公有的辅助类，与外部类一起使用。
- 非静态成员类在声明上没有static修饰，它的实例都隐含关联着一个外部类的实例，常见用法就是做适配器类。
- 匿名类就是没有名字，无法被实例化，主要用于动态地创建小型函数对象和过程对象，以及静态工程方法的内部。
- 局部类是在任何“可以声明局部变量”的地方，都可以声明的类，使用最少。

## 第 25 条：限制源文件为单个顶级类

一个Java文件定义一个 public 类。永远不要把多个顶级类或者接口放在一个源文件中，可能导致给一个类提供多个定义 ，而哪一个定义会被用到，取决于源文件被传给编译器的顺序。

## 第 26 条： 泛型类使用时尽量注明特定类型

不注明类型，就失掉了泛型在安全性和描述性方面的所有优势。如果使用像 `List` 这样的原生态类型，就会失掉类型安全性 ， 但是如果使用像 `List<Object＞` 这样的参数化类型，则不会。

## 第 27 条：消除非受检查的警告

要尽可能地消除每 一 个非受检查警告。用泛型编程时会遇到讲多编译器警告，可以利用在 Java 7 中开始引人的菱形操作符（ diamond operator) ( < ＞ ）将它括起来即可。

```java
Set<Lark> exaltation = new HashSet<>();
```

如果无法消除警告 ，同时可以证明引起警告的代码是类型安全的，可以用 一个`＠Suppre ssWarnings("unchecked")`注解来禁止这条警告，但是应该始终在尽可能小的范围内使用 `SuppressWarnings` 注解，并且都要添加一条注释，说 明为什么这么做是安全的 。

## 第 28 条：列表优于数组

数组与泛型相比，数组是协变的，对象类型关系影响对象集合关系，容易出现运行时错误。

数组与泛型之间的第二大区别在于，数组是具体化的，因此数组会在运行时知道和强化它们的元素类型。

## 第 29 条：优先考虑泛型

将类泛型化的第一步是在它的声明中添加一个或者多个类型参数。

使用泛型比使用需要在客户端代码中进行转换的类型来得更加安全，也更 加容易 。

## 第 30 条：优先考虑泛型方法

声明类型参数的类型参数列表，处在方法的修饰符及其返 回值之间。

```java
// Generic method
public static <E> Set<E> union (Set<E> s1, Set<E> s2){
    Set<E> result = new HashSet<>(s1);
    result.addAll(S2);
    return result;
}
```

## 第 31 条 ：利用有限制通配符来提升 API 的灵活性

泛型中使用 extends 可以进一步限定类型，获得最大限度的灵活性。

```java
// Wildcard type for a parameter that serves as an E producer 
public void pushAll(Iterable <? extends E> src){
  for(E e : src){
    push (e);
  }
}
```

使用时始终应该是 X<? super b> 优先于 X<T＞ ; 如果类型参数只在方法声明中出现一次，就可以用通配符取代它 。

> 速记 PECS : producer- extends, consumer- super。

如果参数化类型表示一个生产者 T ，就使用＜？ extends T ＞；如果它表示 一个消费者 T ，就使用 ＜？ super T ＞



## 第 32 条：谨慎并用泛型和可变参数

不要将值保存在泛型可变参数数组参数中是不安全的，如果需要消除安全警告，需要 `@SafeVarargs` 注解，通过方法的设计者做出承诺，声明这是类型安全的。



##第 33 条：优先考虑类型安全的异构容器

可以通过将类型参数放在键上而不是容器上来避开每个容器只 能有固定数目的类型参数的限制。 对于这种类型安全的异构容器，可以用 Class 对象作为键。



## 第 34 条 ： 用 enum 代替 int 常量

> 什么是枚举类型

枚举类型（ enum type ）是指由一组固定的常量组成合法值的类型。通过公有的静态 final 字段为每个枚举常量导出一个实例，不可实例化和扩展。

枚举类型还允许添加任意的方法和字段，并实现任意的接口。

将不同的行为与每个枚举常量关联起来特定于常量的方法实现：在枚举类 型中声明一个抽象的 appl y 方法，并在特定于常量的类主体中，用具体的方法覆盖每个常量的抽象 apply 方法。

> 什么时候使用枚举？

每当需要一组固定常量．并且在编译 时就知道其成员 的时候，就应该使用枚举，枚举类型中的常量集并不一定要始终保持不变。



## 第 35 条：用实例字段代替序数

所有的枚举都有一个 ordinal 方法，它返回每个枚举常量在类型中的数字位置。想要获取枚举的位置，永远不要根据枚举的序数导出与它关联的值， 而是要将它保存在一个实例域中 。

![image-20190813154431097](http://ww3.sinaimg.cn/large/006tNc79ly1g5y3i0pnrbj30i504pgoo.jpg)

最好完全避免使用 ordinal 方法。

## 第 36 条：用 EnumSet 代替位字段

通过位运算将 int 常量合并成一个集合，位字段。

EnumSet 类可以有效地表示从单个枚举类型中提取的多个值的多个集合，它类型安全，性能好。



## 第 37 条：用 EnumMap 代替序数索引

EnumMap，一种非常快速的 Map 实现专门用于枚举键。

内部使用了数组，与通过序数索引的数组方式的效果一样，集 Map 的丰富功能和类型安全与数组的快速于一身。

最好不要用序数来索引数组 ，而要使用 EnumMap。



## 第 38 条 ：用接口模拟可扩展的枚举

枚举支持任何接口实现，达成扩展的效果。

枚举类型不是可扩展的，但接口类型是可扩展的，它是用来表示 API 中的操作的接口类型 。



## 第 39 条：注解优先于命名模式

有了注解，就完全没有理由再使用命名模式了。



## 第 40 条：坚持使用 Override 注解

@Override 注解只能用在方法声明中，它表示被注解的方法声明覆盖了超类型 中的一个方法声明。在你想要覆盖超类声明的每个方法声明中使用 Override 注解。

## 第 41 条：用标记接口定义类型

> 什么是标记接口？

不包含任何方法声明的接口，只是用来声明某种属性或者类型。比如 Serializable 接口表明一个类可以被序列化。

如果想要定义类型，可以考虑使用接口。



## 第 42 条：Lambda 优先于匿名类

JDK 8 之前，创建函数对象的方式主要是匿名函数，现在有了函数接口，可以使用 Lambda 代替匿名类。

![](http://ww3.sinaimg.cn/large/006tNc79ly1g61xo2kuv9j30zy03m0xa.jpg)

并且使用 Lambda 时充分利用编译器的类型推导，可以删除 Lambda 参数的类型。

与方法和类不同的是， Lambda 是没有名称和文档的；如果一个计算本身不是自描述 的， 或者超出了几行， 那就 要把它放在一个 Lambda 中 。

一行是最理想的， 三行是合理的最大极限，Lambda 很长难以阅读，就要想办法重构简化。



## 第 43 条：方法引用优先于 Lambda

Java 提供了生成比 Lambda 更简洁函数对象的方法 ： 方法引用。只要方法引用更加简洁、清晰，就用方法引用；如果方法引用并不简洁，就坚持使用 Lambda。

![image-20190816233039283](http://ww4.sinaimg.cn/large/006tNc79ly1g61xtwlxuzj30ks02sdgt.jpg)

使用方法引用通常能够得到更加简短、清晰的代码，许多方法引用都指向静态方法，也有例外比如构造器引用

![image-20190816233132173](http://ww2.sinaimg.cn/large/006tNc79ly1g61xust35mj317c0agdn8.jpg)



## 第 44 条：坚持使用标准的函数接口

只要标准的函数接口能够满足需求，通常应该优先考虑，而不是专门再构建一个新的函数接口 。java.util.function 包已经为此提供了大量标准 的函数接口。

![6大基础函数接口](http://ww1.sinaimg.cn/large/006tNc79ly1g61xxirfhij31720acwl8.jpg)

Operator 接口代表其结果与参数类型一致的函数。 Predicate 接口代表带有一个参数 并返回一个 boolean 的函数。 Function 接口代表其参数与返回的类型不一致的函数。 Supplier 接口代表没有参数并且返回（或“提供”）一个值的函数。 最后， Consumer 代表的是带有一个函数但不返回任何值的函数，相 当于消费掉了其参数。

> 千万不要用带包装类型的基础函数接 口来代替基本函数接口 。

如果要自定义函数接口，必须始终用 ＠FunctionInteface 注解对自己编写的函数接 口进行标注。


## 第 45 条：谨慎使用 Stream

Java B 中增加了 Stream API ，简化了串行或并行的大批量操作 。

它虽然简短，但是难以读懂，如果滥用 Stream 会使程序代码更难以读懂和维护 。

![image-20190816234052681](http://ww1.sinaimg.cn/large/006tNc79ly1g61y4jngk8j30wm0f07kx.jpg)

在没有显式类型的情况下，仔细命名 Lambda 参数 ， 这对于 Stream pipeline 的可读性至关重要。

重构现有代码来使用 Stream ，并且只在必要的时候才在新代码中使用 。

如果实在不确定用 Stream 还是用迭代比较好，那么就两种都试试，看看哪一种更好用吧。

## 第 46 条：优先选择 Stream 中无副作用的函数

Stream 并不只是一个 API，它是一种基于函数编程的模型。

- forEach 操作应该只用于报告 Stream 计算 的结果，而不是执行计算。
- 为了正确地使用 Stream ，必须了解收集器。 最重要的收集器工厂是 toList ，toSet 、toMap 、groupingBy 和 joining。



## 第 47 条：Stream 优先用 Collection 作为返回类型

对于公共的、返回序列的方法，Collection 或者适当的子类型通常是最佳的返回类型，千万别在内存中保存巨大的序列，将它作为集合返回即可。

在编写返回一系列元素的方法时，如果可以返回集合，就返回集合。 如 果集合中已经有元素，或者序列中的元素数量很少，足以创建一个新的集合，那么就返回一 个标准的集合，如 ArrayList 。 否则，就要考虑实现一个定制的集合。 如果无法返回集合，就返回 Stream 或者 lterable ，感觉哪一种更自然即可 。



## 第 48 条：谨慎使用 Stream 并行

千万不要任意地并行 Stream pipeline。

因为并行 Stream 不仅可能降低性能，包括活性失败，还可能导致结果出错，以及难以预计 的行为。

想要在 Stream 上通过并行获得的性能， 最好是通过 ArrayList 、 HashMap、 HashSet 和 ConcurrentHashMap 实例，数组， int 范围和 long 范围等。

尽量不要并行 Stream pipeline ，除非有足够的理由相信它能保证计算的正确 性，并且能加快程序的运行速度 。 如果对 Stream 进行不恰当的并行操作，可能导致程序运 行失败，或者造成性能灾难 。



## 第 49 条：检查参数的有效性

使用 Objects.requireNonNull 方法，可以避免手工进行 null 检查

![](http://ww1.sinaimg.cn/large/006tNc79gy1g62pjs2czhj315e03sdkm.jpg)

，每当编写方法或者构造器的时候，应该考虑它的参数有哪些限制 ，并且这些限制写到文档中，并且在这个方法体的开头处，通过显式的检查来实施这些限制。

## 第 50 条：必要时进行保护性拷贝

对于构造器的每个可变参数进 行保护性拷贝是必要的。

保护性拷贝是在检查参数的有效性之前进行的，并且有效性检查是针对拷贝之后的对象， 而不是针对原始的对象 。

> 请不要使用 clone 方法进行保护性拷贝。

## 第 51 条：谨慎设计方法签名

- 谨慎地选择方法的名称，易于理解，风格一致。
- 不要过于追求提供便利的方法。方法太多会使类难以学习、 使用、文档化、测试和维护 。
- 避免过长的参数列表，目标是四个参数或者更少。
  - 把一个方法分解成多个方法
  - 创建辅助类，用来保存参数的分组
  - 从对象构建到方法调用都采用 Builder 模式
- 对于参数类型，要优先使用接口而不是类。
- 对于 boolean 参数，要优先使用两个元素的枚举类型。

## 第 52 条：慎用重载

对一个方法进行多种重载时，要调用哪个重载方法是在编译时就决定的，对于重载方法的选择是静态的，而对于被覆盖的方法 的选择则是动态的 。

永远不要导出两个具有相同参数数目的重载方法，始终可以给方法起不同的名称，而不使用重载机制。

不要在相同的参数位置调用带有不同函数接口的方法，否则可能会有意想不到的结果。



## 第 53 条：慎用可变参数

在定义参数数目不定的方法时，可变参数方法是一种很方便的方式。在使用可变参数之前， 要先包含所有必要的参数，并且要关注使用可变参数所带来的性能影响。



## 第 54 条：返回零长度的集合，而不是 null

永远不要返 回 null ，而不返 回一个零长度的数组或者集合，如果担心性能有影响，可以通过重复返回同一个不可变的共享的零长度集合。



## 第55 条： 谨慎返回 Optional

Optional<T＞类代表的是一 个不可变的容器，它可以存放单个非 null 的 T 引用，或者什么内容都没有 。

如果无法返回结果并且当没有返回结果时客户端必须执行特殊的处理，那么就应该声明该方法返回 Optional<T>。

- 永远不要通过返回 Optional 的方法返回 null,当传入 null 值时就返回一个空的

Optional 。

- 永远不应该返回基本包装类型的 Optional，比返回一个基本类型的开销更高。



## 第 56 条：为所有导出的 API 元素编写文档注释

想使一个 API 真正可用，就必须为其编写文档。必须在每个被导出的类、接口、构造器、方法和字段声明之前增加一个文档注释。

文档注释在源代码和产生的文档中都应该是 易于阅读的 。

- 类或者静态方法是否线程安全，应该在文档中对它的线程安全级别进行说明 。
- 为注解类型编写文档时，要确保在文档中说明所有成员，类型。
- 为枚举类型编写文档时，说明昌平，类型和任何公共方法。
- 为泛型方法编写文档时，确保说明所有的类型参数。



## 第 57 条：将局部变量的作用域最小化

只在在第一次要使用局部变量的地方进行声明，声明都应该包含一个初始化表达式，除了 try-catch 语句，要让使方法小而集中 。

如果在循环终止之后不再需要循环变量的内容，for 循环就优先于 while 循环。



## 第 58 条： for-each 循环优先于for 循环

利用 for-each 循环不会有性能损失，编译器有优化。

for-each 循环在简洁性、灵活性以及出错预防性方 面都占有绝对优势。



## 第 59 条：了解和使用类库

使用标准类库，可以充分利用这些编写标准类库的专家的知识，以及在你之前的其他人的使用经验，也不必浪费时间为那些与工作不太相关的问题提供特别的解决方案 。

每个程序员都 应该熟悉 java. lang 、 java.util 、 java.io 及其子包中的内容。



## 第 60 条：如果需要精确的数值，请避免使用 float 和 double

float 和 double 类型不适合用于货币计算，无法精确地表示 10 的任何其他负数次方值。

是使用 BigDecirnal 、int、long 进行货币计算。如果数值范围没有超过 9 位十进制数字，就可以使用 int ；如果不超过 18 位数字，就可以使用 long 。 如果数值可能超过 18 位数字，就必须使用 BigDecimal 。

## 第 61 条 ： 基本类型优先于装箱基本类型

Java 类型系统组成：基本类型 + 引用类型。装箱基本类型就是基本类型对应的引用类型。

基本类型和装箱基本类型主要区别：

1. 基本类型只有值，装箱基本类型除了值之外还有引用
2. 基本类型只有函数值，装箱基本类型还 null
3. 基本类型通常比装 箱基本类型更节省时间和空间 

**对装箱基本类型运用＝＝操作符几乎都是错误做法 **

当在一项操作中混合使用基本类型和装箱基本类型时，装箱基本导致较高的资源消耗和不必要的对象创建，并且当程序进行拆箱时，会有抛出 NullPointerException 异常的可能。

## 第 62 条：如果其他类型更适合，则尽量避免使用字符串

**字符串不适合代替其他的值类型**

- 字符串不适合代替基本类型

- 字符串不适合代替枚举类型

使用更加合适的数据类型，或者可以编写更加适 当的数据类型， 就应该避免用字符串来表示对象。

## 第 63 条：了解字符串连接的性能

使用字符串连接操作符（＋）不适合运用在大规模的场景中，请用 StringBuilder 代替 String。

**不要使用字符串连接操作符来合并多个字符串** ，除非性能无关紧要 。

## 第 64 条：通过接口引用对象

用接口作为类型，在参数，返回值，变量，字段上使用，程序将会更加灵活。

如果没有适合的接口，就用类层次结构中提供了必要功能的最小的具体类来引用对象。

## 第 65 条：接口优先于反射机制

强大反射机制的缺点：

- 失去了编译时类型检查的优势
- 执行反射访问所需要的代码笨拙和冗长
- 反射方法调用比普通方法调用慢，存在性能损失

## 第 66 条：谨慎地使用本地方法

本地方法是指用本地编程语言（比如 C 或者 C＋＋）来编写的方法。

- 访问特定于平台的功能
- 访问本地遗留代码库
- 提高系统的性能

使用本地方法有严重的缺陷：**本地语言不是安全的**，不可移植，使用不当降低性能，会内存泄漏。

## 第 67 条： 谨慎地进行优化

要努力编写好的程序而不是快的程序。

要努力避免那些限制性能的设计决策 。

要考虑 API 设计决策的性能后果 。

**在每次试图做优化之前和之后，要对性能进行测量**

## 第 68 条：遵守普遍接受的命名惯例

可以借鉴 《 The Java Language Specification 》中的命名惯例，把标准的命名惯例当作一种内在的机制来看待。

## 第 69 条：只针对异常的情况才使用异常

异常机制的设计初衷是用于不正常的情形，当代码防止try-catch 块中会阻止 JVM 特定的优化。

基于异常的模式比标准模式要慢得多 ，因此异常应该只用于异常的情况下；它们永远不应该

用于正常的控制流。

## 第 70 条：对可恢复的情况使用受检查异常，对编程错误采用运行时异常

如果期望调用者能够适当地恢复 ， 对于这种情况就应该使用受检查异常。如果是编程错误，用运行时异常。

## 第 71 条：避免不必要地使用受检异常

在谨慎使用的前提之下，受检异常可以提升程序的可读性；如果过度使用， 将会使 API 使用起来非常痛苦。

## 第 72 条：优先使用标准的异常

重用 Java 平台类库提供了一组基本标准的未受检查异常。

- 使 API 更易于学习和使用
- 可读性会更好

常见重用的异常：`IllegalArgumentException`，`IllegalStateException`，`UnsupportedOperationException`。

不要直接重用 `Exception` ，`RuntimeException`，`Throwable`，`Error`。


## 第 73 条：抛出与抽象对应的异常

异常转译：更高层的实现应该捕获低层的异常，同时抛出可以按照高层抽象进行解释的异常 。
## 第 74 条：每个方法抛出的所有异常都要建立文档

始终要单独地声明受检异常，利用 @throws 标签，准确注明抛出异常的条件，不要使用 throws 关键字将未受检的异常包含在方法的声明中。

## 第 75 条 ： 在细节消息中包含失败 一 捕获信息

为了捕获失败，异常的细节信息应该包含“对该异常有用”的参数和值，但是不要汉堡密码，密钥之类的信息。

## 第 76 条：努力使失败保持原子性

失败原子性：失败的方法调用应该使对象保持在被调用之前的状态，出现失败情况时让对象可恢复之前的状态。

- 使用一个不可变的对象
- 调整计算处理过程的顺序，使得任何可能会失败的计算部分都在对象状态被修改之前发生 。
- 在对象的一份临时拷贝上执行操作，当操作完成之 后再用临时拷贝中的结果代替对象的内容。
- 提供用于失败回滚的代码

## 第 77 条：不要忽略异常

如果选择忽略异常， catch 块中应该包含一条注释，说明为什么可以这么做，空的 catch 块会使异常信息失去了意义。

## 第 78 条：同步访问共享的可变数据

为了在线程之间进行可靠的通信，也为了互斥访问，使用 synchronized 是很有必要的 。

除非读和写操作都被同步，否则无法保证同步能起作用 。避免数据不一致的问题最好办法就是不共享可变的数据，将可变数据限制在单个线程中 。

## 第 79 条：避免过度同步

过度同步则可能导致性能降低 、死锁，甚至系统异常。因此，应该在同步区域内做尽可能少的工作，千万不要从同步区域内部调用外来方法。

## 第 80 条：executor 、task 和 stream 优先于线程

尽量不要编写自己的工作队列，尽量不直接使用线程，容易出现安全问题。利用 Executor Framework ，将工作单元和执行机制分开。

## 第 81 条：并发工具优先于 wait 和 notify

使用 wait 和 notify 容易出错，应该使用更高级的并发工具代替：Executor Framework，并发集合，Synchronizer。

应该优先使用 ConcurrentHashMap ，而不是使用 Collections. synchronizedMap 。

同步器（ Synchronizer ）是使线程能够等待另一个线程的对象，允许它们协调动作 ，比如 CountDownLatch 和 Semaphore。

对于定时，始终应该优先使用 System.nanoTime ，而不是使用 System.currentTimeMillis ,更准确，不受系统的实时时钟影响。

## 第 82 条：线程安全性的文档化

如果一个类为了可被多个钱程安全地使用，必须在文档中清楚地说明它所支持的线程安全性级别 。

常见的形式：

- 不可变的
- 无条件的线程安全
- 有条件的结程安全
- 非线程安全
- 线程对立的

## 第 83 条：慎用延迟初始化

延迟初始化指延迟到需要字段的值时才将它初始化的行为 ，如果不需要就不会被初始化。

在大多数情况下 ， 正常的初始化要优先于延迟初始化 。如果出于性能 的考虑而需要对静态字段使用延迟初始化，就使 用 lazy initialization holder class 模式。

![](http://ww1.sinaimg.cn/large/006y8mN6ly1g68rzqz7wuj30ti052n1p.jpg)

如果出于性能的考虑而需要对实例字段使用延迟初始化 ， 就使用双重检查模式

![](http://ww4.sinaimg.cn/large/006y8mN6ly1g68s2d1fcgj30ug08s3zk.jpg)

## 第 84 条：不要依赖于线程调度器

当有多个线程可以运行时，会由线程调度器（ thread scheduler ）决定哪些线程将会运行， 以及运行多长时间 。任何依赖于线程调度器来达到正确性或者性能要求的程序，都是不可靠的。

不要依赖 Thread.yield 或者线程优先级，调整程序多线程下的行为。

## 第 85 条：其他方法优先于 Java 序列化

序列化攻击：对象图是通过在 ObjectInputStream 上调用 readObject 方法进行反序列化的 。 这个方法其实是个神奇的构造器，它可以将类路径上几乎任何类型的对象都实例化，只要该类型实现了 Serializable 接口 。 在反序列化字节流的过程中，该方法可以执行以上任意类型的代码。

避免序列化攻击的最佳方式是永远不要反序列化任何东西，并且永远不要反序列化不被信任的数据。
