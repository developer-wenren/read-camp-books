# 第六期 《Effective Java中文版（第3版）》
> 阅读计划：每天 5 条，总共18天。读六天，复习一天，截止 20190823。

## 第1条 用静态工厂方法代替构造器

- 有什么好处？

- 如何做到？

### 五大使用静态工厂方法的优势

1. 允许提供更有意义的名称，更利于理解和使用，而不是固定的构造器名称。
2. 可以避免重复创建对象，节省内存，对预先创建的对象进行缓存，反复使用。
3. 可以指定类的任意子类对象，利用多态，更加灵活
4. 允许在内部实现中包含的类不存在，如 服务提供者接口（SPI），JDBC
5. 允许根据不同参数构造不同的对象，多个构造器方法容易调用错。



### 常见的静态工厂方法惯用名称

- from： 类型转换方法，它只有单个参数，返回该类型的一个相对应的实例

	```java
	Date d = Date.from(instant);
	```

- of：聚合方法，带有多个参数，返回该类型的一个实例，把它们合并起来

	```java
	Set<Rank> faceCards = EnumSet.of(JACK , QUEEN, KING);
	```

- valueOf： from 和 of 更烦琐的一种替代方法

	```java
	Biginteger a = Biginteger.valueOf(Integer.MAX_VALUE);
	```

- instance 或者 get Instance一－返回的实例是通过方法的（如有）参数来 描述

	的，但是不能说与参数具有同样的值

	```java
	StackWalker luke = StackWalker .getinstance(options);
	```

- create 或者 newInstance一一像 instance 或者 getInstance 一样，但 create 或者 newInstance 能够确保每次调用都返回一个新的实例

	```java
	Object newArray = Array.newinstance(classObject, arraylen)
	```

- getType：像 get Instance 一 样，但是在工厂方法处于不同的类中的时候使 用 。 Type 表示工厂方法所返回的对象类型

	```java
	FileStore fs = Files.getFileStore(path);
	```

- newType：像 newInstance 一样，但是在工厂方法处于不同的类中的时候使用,Type 表示工厂方法所返回的对象类型

	```java
	BufferedReader br＝ Files.newBufferedReader(path);
	```

- type：getType 和 newType 的简版

	```java
	List<Complaint> litany ＝Collections.list(legacylitany);
	```

### 小结

构建实例时，优先考虑静态工厂，而不是第一反应定义构造器方法；多考虑静态工厂，多考虑静态工厂，考虑静态工厂。

## 第2条. 遇到多个构造器参数时要考虑使用构建器

- 为什么要这样做？
- 怎么做？

### 建造者模式 Builder Pattern

面对构建一个对象需要大量必备参数和可选参数时，使用构造器方式构建往往混乱难以维护，并且容易出错；利用建造者模式 Builder Pattern，使用 构建器对象 `builder` 来构建对象所需要的参数，必填参数作为构造器参数，可选参数采用赋值方法，结合流式 API 方式通过 `build` 方法构建完整对象.

![](http://ww2.sinaimg.cn/large/006tNc79ly1g5p6do7nljj30me0stmyv.jpg)

### 小结

当类的构造器或者静态工厂中具有多个参数，设计这种类时，优先考虑 Builder 模式，尤其是大多数参数可选或者类型相同的情况下，这样可读性好，有便于维护。

初次之外还可以利用 Lombok 框架的 @Builder 注解，自动生成  Builder 模式的固定代码。

## 第3条 用私有构造器或者枚举类型强化 Singleton 属性

怎么用到枚举类型？

对单例的要求哪有？

作为一个单例，全局唯一，只能有一个实例，并且反序列后仍是同个实例，这一点必须实现 `Serializable` 接口和 `readResolve()` 方法解决。

### 单元素枚举实现单例

单例对象要求防止被重复实例化，以及反序列和序列化后都是同一个实例，优先采用单元素枚举类型的实现方式。

![](http://ww1.sinaimg.cn/large/006tNc79ly1g5p6gjmznoj311s0i2mym.jpg)


### 小结

枚举类型单例也有局限，当单例需要扩展于一个父类时，不能基于 Enum 扩展。

如果需要一个没有父类的单例对象，可以考虑使用枚举方式定义。



## 第4条 通过私有构造器强化不可实例化的能力

- 通用的解决方式是什么样的？
- 针对哪些类

为这个类定义一个私有构造器，它就不能被实例化，并且提供调用的异常提示。

缺陷在于该类就无法被继承使用，因为所有构造器都必须调用父类构造器。

### 小结

通常只提供静态方法和静态字段的类，需要对构造器私有化处理。


## 第5 条 优先考虑依赖注人来引用资源

- 什么场景下使用依赖注入？
- 依赖注入有什么副作用吗？

### 依赖注入 DI

当构建一个实例时，所需的资源通过构造器方式或者特定的赋值方法传入，而不是用静态工具类和单例类使用底层资源。

### 小结

依赖注入虽然灵活，易于测试，但是当依赖过多和关系复杂时就难以维护。



## 第6条 避免创建不必要的对象

> 哪些场景下可以重用对象?

重用对象可以提供性能。

对于不可变的对象来说，一直是可以被重用的。

对于已知不会被修改的可变对象，也可以重用。

> 如何重用对象？

- 自动装箱会创建多余对象，应该优先使用基本类型。

- 针对重量级对象，合理利用对象池，比如数据库连接池，线程池。

- 使用正则表达式，单独声明 Pattern 实例再使用

## 第7条 消除过期的对象引用

> 怎么算过期的引用

过期引用 （ obsolete reference ）: 永远也不会再被解除的引用，但不会被访问到。

过期引用会导致出现内存泄漏，需要及时地清空引用。

当类自己管理内存时，就应该警惕内存泄漏问题，及时清空不被使用的引用。

常见的过期引用场景：

- 自动管理内存

- 缓存
- 监听器和回调，用弱引用处理



如何发现内存泄漏

1. 仔细检查代码
2. 借助 Heap 剖析工具，如 MAT。



## 第8条 避免使用finalize方法和cleaner方法

> 为什么不要使用这些方法？

这些方法执行跟 JVM 相关;

严重拖慢性能;

存在安全问题，执行恶意的 finalize 方法，形成攻击。



## 第9条 try-with-resources 优先于 try-finally

Java 7 引入 try-with-resource 语句，资源类实现 `AutoCloseable` 接口

 try-with-resource 支持 

```java
static String firstLineOfFile(String path) throws IOException {
  try (BufferedReader br = new BufferedReader(new FileReader(path))) {
    return br.readLine();
  }
}

static void copy(String src, String dest) throws IOException {
  try (InputStream in = new FileInputStream(src); OutputStream out = new FileOutputStream(dest)) {
    byte[] buffer = new byte[1024];
    int n;
    while ((n = in.read(buffer)) >= 0) {
      out.write(buffer, 0, n);
    }
  }
}
```

### 小结

在处理必须关闭的资源时，始终要优先考虑用 try-with-resources ，而不是 用 try-finally 。 这样得到的代码将更加简洁、清晰，产生的异常也更有价值。



## 第10条 覆盖 equals 时请遵守通用约定

不要随意覆盖 equals 方法：

- 类的每个实例本质上都是唯一的
- 类没有必要提供“逻辑相等”（ logical equality ）的测试功能
- 超类已经覆盖了 equals ，超类的行为对于这个 类 也是合适的
- 类是私有的 ， 或者是包级私有的 ， 可以确定它的 equals 方法永远不会 被调用 。



如何实现 equals 方法：

1. 使用＝＝操作符检查“参数是否为这个对象的引用”。
2. 使用 instanceof 操作符检查“参数是否为正确的类型”。
3. 把参数转换成正确的类型。
4. 对于该类中的每个“关键”（ significant ）字段，检查参数中的字段是否与该对象中对应的字段相匹配。
5. 覆盖 equals 时总要覆盖 hashCode。

##  第11条 覆写 equals 方法总要覆盖 hashCode 方法

> 为什么需要这样做？

在一些基于`Hash` 的集合里就无法正常的工作，如 `HashMap`，`HashSet`。

两个对象 `equals` 方法不相等，`hashCode` 方法不一定也相等，但尽量保证两个方法的一致

> 如何正确地覆写 `hashCode` 方法

结合对象的关键字段进行组合 `hash` 作为对象的 `hashCode` 。

```java
@Override public int hashCode() {
	return Objects.hash(linenum, prefix, areacode)
}
```

注意：如果计算对象的哈希码开销较大时，可以考虑缓存方式，延迟加载初始化 `hashCode`。

## 第12条 始终覆盖 toString 方法

提供自定义的 `toString` 实现，在日志打印时让对象更加容易查看，便于调试，将方法里返回对象包含的所有需要关注的值。

## 第13条 不要轻易覆盖 clone 方法

`clone` 方法的作用就是可以无须调用构造器就可以创建对象。

`clone` 方法与可变对象的 final 字段不兼容。

如何克隆复杂对象是，先调用 `super . clone` 方法，然后把结果对象中的 所有域都设置成它们 的初始状态（ initial state ），然后调用高层（ higher-level ）的方法来重 新产生对象的状态 。

对象拷贝的更好的办法是提供一个拷贝构造器（ copy constructor）或拷贝工厂（ copy factory ）



## 第14条 考虑实现 Comparable 接口

如果实现了 `Comparable` 接口，那么在通常情况下应该返回与 `equals` 方法同样的结果。

如果第一个值小于第二个值，则为负；如果两个值相等 ，则为零 ；如果第一个值大于第二个值，则为正 。

需要比较时，可以使用 Comparator 接口中比较器构造方法。



## 第15条 使类和成员的可访问性最小化

也叫做封装，尽可能地使每个类或者成员不被外界访问 。

可访问性关键字从低到高：

- private
- package-private 默认
- protected
- public

公共类都不应该包含 `public` 字段，并且 要确保公有静态 `final` 域所引用的对象都是不可变的 。

## 第 16 条：要在公共类使用方法访问字段，而不是将其公开

如果类可以在它所在的包之外进行访问，就应该提供访问方法。

## 第 17 条：使可变性最小化

> 什么是不可变类

实例不能被修改的类，如 String，基本类型包装类。

> 如何变成不可变类

- 不提供任何赋值方法
- final 修饰，保证类不会被扩展
- 声明所有的字段都是 final 修饰
- 所有方法都是私有的
- 不允许外部获取实例内引用指向可变对象的字段

> 不可变对象的优势在哪

不可变对象是线程安全的，可以共享它们的内部信息，状态始终保持一致性。

构造器应该创建完全初始化的对象 ，并建立起所有的约束关系。

## 第 18 条：复合优先于继承

> 为什么不使用继承

继承打破了封装性，让子类依赖其父类的实现细节。

> 什么是复合

在新的类中增加一个私有字段，引用现有类的一个实例，新类中的每个实例方法都可以调用被包含的现有类实例中对应的方法，并返回它的结果 。

## 第 19 条：如果使用继承要提供文档说明

父类必须有文档说明它可覆盖的方法的自用性。并且在发布类之前先编写子类对类进行测试。

父类的约束：构造器决不能调用可被覆盖的方法，避免子类覆写后行为异常。

## 第 20 条：接口优于抽象类

> 什么是 mixin 类型

类除了实现 它的“基本类型”之外，还可以实现特定接口提供了某些可供选择的行为，如 Comparable 接口。

接口通常是定义允许多个实现类型的最佳途径。

## 第 21 条 ： 为后代设计接口

Java 8 引入新特性：让接口可以用默认实现的方法。但是接口的现有实现就不会出现编译时没有报错或警告，运行时却失败的情况 ，仍要谨慎设计接口，为接口添加默认方法时候要全面测试。

## 第 22 条：接口只用于定义类型

不要用接口用来定义常量类，一旦这个接口被非`final`类实现了，所有子类 的命名空 间也会被接 口中的常量所“污染”。替代方案是使用枚举类型或者不可实例化的工具类。

## 第 23 条 ： 类层次优于标签类

> 什么是标签类

包含表示实例风格字段的类，充斥着样板代码，包括枚举声明、标签字段以及条件语句 。

标签类过于冗长、容易出错，并且效率低下，替代的方案为拆成类，进行层次维护，用来反映类型之间本质上的层次关系，有助于增 强灵活性，并有助于更好地进行编译时类型检查 。

## 第 24 条 ： 静态成员类优于非静态成员类

嵌套类有四种：静态成员类，非静态成员类，匿名类，局部类。

- 静态成员类用于公有的辅助类，与外部类一起使用。
- 非静态成员类在声明上没有static修饰，它的实例都隐含关联着一个外部类的实例，常见用法就是做适配器类。
- 匿名类就是没有名字，无法被实例化，主要用于动态地创建小型函数对象和过程对象，以及静态工程方法的内部。
- 局部类是在任何“可以声明局部变量”的地方，都可以声明的类，使用最少。

## 第 25 条：限制源文件为单个顶级类

一个Java文件定义一个 public 类。永远不要把多个顶级类或者接口放在一个源文件中，可能导致给一个类提供多个定义 ，而哪一个定义会被用到，取决于源文件被传给编译器的顺序。

## 第 26 条： 泛型类使用时尽量注明特定类型

不注明类型，就失掉了泛型在安全性和描述性方面的所有优势。如果使用像 `List` 这样的原生态类型，就会失掉类型安全性 ， 但是如果使用像 `List<Object＞` 这样的参数化类型，则不会。

## 第 27 条：消除非受检查的警告

要尽可能地消除每 一 个非受检查警告。用泛型编程时会遇到讲多编译器警告，可以利用在 Java 7 中开始引人的菱形操作符（ diamond operator) ( < ＞ ）将它括起来即可。

```java
Set<Lark> exaltation = new HashSet<>();
```

如果无法消除警告 ，同时可以证明引起警告的代码是类型安全的，可以用 一个`＠Suppre ssWarnings("unchecked")`注解来禁止这条警告，但是应该始终在尽可能小的范围内使用 `SuppressWarnings` 注解，并且都要添加一条注释，说 明为什么这么做是安全的 。

## 第 28 条：列表优于数组

数组与泛型相比，数组是协变的，对象类型关系影响对象集合关系，容易出现运行时错误。

数组与泛型之间的第二大区别在于，数组是具体化的，因此数组会在运行时知道和强化它们的元素类型。

## 第 29 条：优先考虑泛型

将类泛型化的第一步是在它的声明中添加一个或者多个类型参数。

使用泛型比使用需要在客户端代码中进行转换的类型来得更加安全，也更 加容易 。

## 第 30 条：优先考虑泛型方法

声明类型参数的类型参数列表，处在方法的修饰符及其返 回值之间。

```java
// Generic method
public static <E> Set<E> union (Set<E> s1, Set<E> s2){
    Set<E> result = new HashSet<>(s1);
    result.addAll(S2);
    return result;
}
```

## 第 31 条 ：利用有限制通配符来提升 API 的灵活性

泛型中使用 extends 可以进一步限定类型，获得最大限度的灵活性。

```java
// Wildcard type for a parameter that serves as an E producer 
public void pushAll(Iterable <? extends E> src){
  for(E e : src){
    push (e);
  }
}
```

使用时始终应该是 X<? super b> 优先于 X<T＞ ; 如果类型参数只在方法声明中出现一次，就可以用通配符取代它 。

> 速记 PECS : producer- extends, consumer- super。

如果参数化类型表示一个生产者 T ，就使用＜？ extends T ＞；如果它表示 一个消费者 T ，就使用 ＜？ super T ＞



## 第 32 条：谨慎并用泛型和可变参数

不要将值保存在泛型可变参数数组参数中是不安全的，如果需要消除安全警告，需要 `@SafeVarargs` 注解，通过方法的设计者做出承诺，声明这是类型安全的。



##第 33 条：优先考虑类型安全的异构容器

可以通过将类型参数放在键上而不是容器上来避开每个容器只 能有固定数目的类型参数的限制。 对于这种类型安全的异构容器，可以用 Class 对象作为键。



## 第 34 条 ： 用 enum 代替 int 常量

> 什么是枚举类型

枚举类型（ enum type ）是指由一组固定的常量组成合法值的类型。通过公有的静态 final 字段为每个枚举常量导出一个实例，不可实例化和扩展。

枚举类型还允许添加任意的方法和字段，并实现任意的接口。

将不同的行为与每个枚举常量关联起来特定于常量的方法实现：在枚举类 型中声明一个抽象的 appl y 方法，并在特定于常量的类主体中，用具体的方法覆盖每个常量的抽象 apply 方法。

> 什么时候使用枚举？

每当需要一组固定常量．并且在编译 时就知道其成员 的时候，就应该使用枚举，枚举类型中的常量集并不一定要始终保持不变。



## 第 35 条：用实例字段代替序数

所有的枚举都有一个 ordinal 方法，它返回每个枚举常量在类型中的数字位置。想要获取枚举的位置，永远不要根据枚举的序数导出与它关联的值， 而是要将它保存在一个实例域中 。

![image-20190813154431097](http://ww3.sinaimg.cn/large/006tNc79ly1g5y3i0pnrbj30i504pgoo.jpg)

最好完全避免使用 ordinal 方法。

## 第 36 条：用 EnumSet 代替位字段

通过位运算将 int 常量合并成一个集合，位字段。

EnumSet 类可以有效地表示从单个枚举类型中提取的多个值的多个集合，它类型安全，性能好。



## 第 37 条：用 EnumMap 代替序数索引

EnumMap，一种非常快速的 Map 实现专门用于枚举键。

内部使用了数组，与通过序数索引的数组方式的效果一样，集 Map 的丰富功能和类型安全与数组的快速于一身。

最好不要用序数来索引数组 ，而要使用 EnumMap。



## 第 38 条 ：用接口模拟可扩展的枚举

枚举支持任何接口实现，达成扩展的效果。

枚举类型不是可扩展的，但接口类型是可扩展的，它是用来表示 API 中的操作的接口类型 。



## 第 39 条：注解优先于命名模式

有了注解，就完全没有理由再使用命名模式了。



## 第 40 条：坚持使用 Override 注解

@Override 注解只能用在方法声明中，它表示被注解的方法声明覆盖了超类型 中的一个方法声明。在你想要覆盖超类声明的每个方法声明中使用 Override 注解。

## 第 41 条：用标记接口定义类型

> 什么是标记接口？

不包含任何方法声明的接口，只是用来声明某种属性或者类型。比如 Serializable 接口表明一个类可以被序列化。

如果想要定义类型，可以考虑使用接口。



## 第 42 条：Lambda 优先于匿名类

JDK 8 之前，创建函数对象的方式主要是匿名函数，现在有了函数接口，可以使用 Lambda 代替匿名类。

![](http://ww3.sinaimg.cn/large/006tNc79ly1g61xo2kuv9j30zy03m0xa.jpg)

并且使用 Lambda 时充分利用编译器的类型推导，可以删除 Lambda 参数的类型。

与方法和类不同的是， Lambda 是没有名称和文档的；如果一个计算本身不是自描述 的， 或者超出了几行， 那就 要把它放在一个 Lambda 中 。

一行是最理想的， 三行是合理的最大极限，Lambda 很长难以阅读，就要想办法重构简化。



## 第 43 条：方法引用优先于 Lambda

Java 提供了生成比 Lambda 更简洁函数对象的方法 ： 方法引用。只要方法引用更加简洁、清晰，就用方法引用；如果方法引用并不简洁，就坚持使用 Lambda。

![image-20190816233039283](http://ww4.sinaimg.cn/large/006tNc79ly1g61xtwlxuzj30ks02sdgt.jpg)

使用方法引用通常能够得到更加简短、清晰的代码，许多方法引用都指向静态方法，也有例外比如构造器引用

![image-20190816233132173](http://ww2.sinaimg.cn/large/006tNc79ly1g61xust35mj317c0agdn8.jpg)



## 第 44 条：坚持使用标准的函数接口

只要标准的函数接口能够满足需求，通常应该优先考虑，而不是专门再构建一个新的函数接口 。java.util.function 包已经为此提供了大量标准 的函数接口。

![6大基础函数接口](http://ww1.sinaimg.cn/large/006tNc79ly1g61xxirfhij31720acwl8.jpg)

Operator 接口代表其结果与参数类型一致的函数。 Predicate 接口代表带有一个参数 并返回一个 boolean 的函数。 Function 接口代表其参数与返回的类型不一致的函数。 Supplier 接口代表没有参数并且返回（或“提供”）一个值的函数。 最后， Consumer 代表的是带有一个函数但不返回任何值的函数，相 当于消费掉了其参数。

> 千万不要用带包装类型的基础函数接 口来代替基本函数接口 。

如果要自定义函数接口，必须始终用 ＠FunctionInteface 注解对自己编写的函数接 口进行标注。


## 第 45 条：谨慎使用 Stream

Java B 中增加了 Stream API ，简化了串行或并行的大批量操作 。

它虽然简短，但是难以读懂，如果滥用 Stream 会使程序代码更难以读懂和维护 。

![image-20190816234052681](http://ww1.sinaimg.cn/large/006tNc79ly1g61y4jngk8j30wm0f07kx.jpg)

在没有显式类型的情况下，仔细命名 Lambda 参数 ， 这对于 Stream pipeline 的可读性至关重要。

重构现有代码来使用 Stream ，并且只在必要的时候才在新代码中使用 。

如果实在不确定用 Stream 还是用迭代比较好，那么就两种都试试，看看哪一种更好用吧。
